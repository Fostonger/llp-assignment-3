/**
 * Autogenerated by Thrift Compiler (0.19.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "structs_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_predicate_arg_type_T(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case PREDICATE_ARG_TYPE__T_LITERAL_T:return "PREDICATE_ARG_TYPE__T_LITERAL_T";
  case PREDICATE_ARG_TYPE__T_REFERENCE_T:return "PREDICATE_ARG_TYPE__T_REFERENCE_T";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_predicate_type_T(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case PREDICATE_TYPE__T_COMPARISON_T:return "PREDICATE_TYPE__T_COMPARISON_T";
  case PREDICATE_TYPE__T_STR_MATCH_T:return "PREDICATE_TYPE__T_STR_MATCH_T";
  case PREDICATE_TYPE__T_COMPOUND_T:return "PREDICATE_TYPE__T_COMPOUND_T";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_literal_type_T(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case LITERAL_TYPE__T_LIT_INTEGER_T:return "LITERAL_TYPE__T_LIT_INTEGER_T";
  case LITERAL_TYPE__T_LIT_STRING_T:return "LITERAL_TYPE__T_LIT_STRING_T";
  case LITERAL_TYPE__T_LIT_BOOLEAN_T:return "LITERAL_TYPE__T_LIT_BOOLEAN_T";
  case LITERAL_TYPE__T_LIT_FLOAT_T:return "LITERAL_TYPE__T_LIT_FLOAT_T";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_status_code_T(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case STATUS_CODE__T_OK:return "STATUS_CODE__T_OK";
  case STATUS_CODE__T_TABLE_NOT_FOUND:return "STATUS_CODE__T_TABLE_NOT_FOUND";
  case STATUS_CODE__T_BAD_REQUEST:return "STATUS_CODE__T_BAD_REQUEST";
  case STATUS_CODE__T_INTERNAL_ERROR:return "STATUS_CODE__T_INTERNAL_ERROR";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _types_TProperties
{
  PROP_TYPES__T_0,
  PROP_TYPES__T_BOOLEAN,
  PROP_TYPES__T_NUM,
  PROP_TYPES__T_FLT,
  PROP_TYPES__T_STR
};

/* reads a types__t object */
static gint32
types__t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  types_T * this_object = TYPES__T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->boolean, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_boolean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->num, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_num = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->flt, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_flt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->str != NULL)
          {
            g_free(this_object->str);
            this_object->str = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->str, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_str = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
types__t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  types_T * this_object = TYPES__T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "types_T", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_boolean == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "boolean", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->boolean, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_num == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "num", T_I32, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->num, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_flt == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "flt", T_DOUBLE, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, this_object->flt, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_str == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "str", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->str, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
types__t_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  types_T *self = TYPES__T (object);

  switch (property_id)
  {
    case PROP_TYPES__T_BOOLEAN:
      self->boolean = g_value_get_int (value);
      self->__isset_boolean = TRUE;
      break;

    case PROP_TYPES__T_NUM:
      self->num = g_value_get_int (value);
      self->__isset_num = TRUE;
      break;

    case PROP_TYPES__T_FLT:
      self->flt = g_value_get_double (value);
      self->__isset_flt = TRUE;
      break;

    case PROP_TYPES__T_STR:
      if (self->str != NULL)
        g_free (self->str);
      self->str = g_value_dup_string (value);
      self->__isset_str = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
types__t_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  types_T *self = TYPES__T (object);

  switch (property_id)
  {
    case PROP_TYPES__T_BOOLEAN:
      g_value_set_int (value, self->boolean);
      break;

    case PROP_TYPES__T_NUM:
      g_value_set_int (value, self->num);
      break;

    case PROP_TYPES__T_FLT:
      g_value_set_double (value, self->flt);
      break;

    case PROP_TYPES__T_STR:
      g_value_set_string (value, self->str);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
types__t_instance_init (types_T * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->boolean = 0;
  object->__isset_boolean = FALSE;
  object->num = 0;
  object->__isset_num = FALSE;
  object->flt = 0;
  object->__isset_flt = FALSE;
  object->str = NULL;
  object->__isset_str = FALSE;
}

static void 
types__t_finalize (GObject *object)
{
  types_T *tobject = TYPES__T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->str != NULL)
  {
    g_free(tobject->str);
    tobject->str = NULL;
  }
}

static void
types__t_class_init (types_TClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = types__t_read;
  struct_class->write = types__t_write;

  gobject_class->finalize = types__t_finalize;
  gobject_class->get_property = types__t_get_property;
  gobject_class->set_property = types__t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TYPES__T_BOOLEAN,
     g_param_spec_int ("boolean",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TYPES__T_NUM,
     g_param_spec_int ("num",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TYPES__T_FLT,
     g_param_spec_double ("flt",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TYPES__T_STR,
     g_param_spec_string ("str",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
types__t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (types_TClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) types__t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (types_T),
      0, /* n_preallocs */
      (GInstanceInitFunc) types__t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "types_TType",
                                   &type_info, 0);
  }

  return type;
}

enum _columnref_TProperties
{
  PROP_COLUMNREF__T_0,
  PROP_COLUMNREF__T_TABLE_NAME,
  PROP_COLUMNREF__T_COL_NAME
};

/* reads a columnref__t object */
static gint32
columnref__t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  columnref_T * this_object = COLUMNREF__T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->table_name != NULL)
          {
            g_free(this_object->table_name);
            this_object->table_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->table_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_table_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->col_name != NULL)
          {
            g_free(this_object->col_name);
            this_object->col_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->col_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_col_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
columnref__t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  columnref_T * this_object = COLUMNREF__T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "columnref_T", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_table_name == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "table_name", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->table_name, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "col_name", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->col_name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
columnref__t_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  columnref_T *self = COLUMNREF__T (object);

  switch (property_id)
  {
    case PROP_COLUMNREF__T_TABLE_NAME:
      if (self->table_name != NULL)
        g_free (self->table_name);
      self->table_name = g_value_dup_string (value);
      self->__isset_table_name = TRUE;
      break;

    case PROP_COLUMNREF__T_COL_NAME:
      if (self->col_name != NULL)
        g_free (self->col_name);
      self->col_name = g_value_dup_string (value);
      self->__isset_col_name = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
columnref__t_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  columnref_T *self = COLUMNREF__T (object);

  switch (property_id)
  {
    case PROP_COLUMNREF__T_TABLE_NAME:
      g_value_set_string (value, self->table_name);
      break;

    case PROP_COLUMNREF__T_COL_NAME:
      g_value_set_string (value, self->col_name);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
columnref__t_instance_init (columnref_T * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->table_name = NULL;
  object->__isset_table_name = FALSE;
  object->col_name = NULL;
  object->__isset_col_name = FALSE;
}

static void 
columnref__t_finalize (GObject *object)
{
  columnref_T *tobject = COLUMNREF__T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->table_name != NULL)
  {
    g_free(tobject->table_name);
    tobject->table_name = NULL;
  }
  if (tobject->col_name != NULL)
  {
    g_free(tobject->col_name);
    tobject->col_name = NULL;
  }
}

static void
columnref__t_class_init (columnref_TClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = columnref__t_read;
  struct_class->write = columnref__t_write;

  gobject_class->finalize = columnref__t_finalize;
  gobject_class->get_property = columnref__t_get_property;
  gobject_class->set_property = columnref__t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMNREF__T_TABLE_NAME,
     g_param_spec_string ("table_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMNREF__T_COL_NAME,
     g_param_spec_string ("col_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
columnref__t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (columnref_TClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) columnref__t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (columnref_T),
      0, /* n_preallocs */
      (GInstanceInitFunc) columnref__t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "columnref_TType",
                                   &type_info, 0);
  }

  return type;
}

enum _literal_TProperties
{
  PROP_LITERAL__T_0,
  PROP_LITERAL__T_TYPE,
  PROP_LITERAL__T_VALUE
};

/* reads a literal__t object */
static gint32
literal__t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  literal_T * this_object = LITERAL__T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast0;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast0, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (literal_type_T)ecast0;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
literal__t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  literal_T * this_object = LITERAL__T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "literal_T", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
literal__t_set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  literal_T *self = LITERAL__T (object);

  switch (property_id)
  {
    case PROP_LITERAL__T_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_LITERAL__T_VALUE:
      if (self->value != NULL)
        g_object_unref (self->value);
      self->value = g_value_dup_object (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
literal__t_get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  literal_T *self = LITERAL__T (object);

  switch (property_id)
  {
    case PROP_LITERAL__T_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_LITERAL__T_VALUE:
      g_value_set_object (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
literal__t_instance_init (literal_T * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->value = g_object_new (TYPE_TYPES__T, NULL);
  object->__isset_value = FALSE;
}

static void 
literal__t_finalize (GObject *object)
{
  literal_T *tobject = LITERAL__T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->value != NULL)
  {
    g_object_unref(tobject->value);
    tobject->value = NULL;
  }
}

static void
literal__t_class_init (literal_TClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = literal__t_read;
  struct_class->write = literal__t_write;

  gobject_class->finalize = literal__t_finalize;
  gobject_class->get_property = literal__t_get_property;
  gobject_class->set_property = literal__t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_LITERAL__T_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LITERAL__T_VALUE,
     g_param_spec_object ("value",
                         NULL,
                         NULL,
                         TYPE_TYPES__T,
                         G_PARAM_READWRITE));
}

GType
literal__t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (literal_TClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) literal__t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (literal_T),
      0, /* n_preallocs */
      (GInstanceInitFunc) literal__t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "literal_TType",
                                   &type_info, 0);
  }

  return type;
}

enum _predicate_arg_union_TProperties
{
  PROP_PREDICATE_ARG_UNION__T_0,
  PROP_PREDICATE_ARG_UNION__T_LITERAL,
  PROP_PREDICATE_ARG_UNION__T_REF
};

/* reads a predicate_arg_union__t object */
static gint32
predicate_arg_union__t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  predicate_arg_union_T * this_object = PREDICATE_ARG_UNION__T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->literal), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_literal = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ref), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ref = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
predicate_arg_union__t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  predicate_arg_union_T * this_object = PREDICATE_ARG_UNION__T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "predicate_arg_union_T", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_literal == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "literal", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->literal), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ref == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ref", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ref), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
predicate_arg_union__t_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  predicate_arg_union_T *self = PREDICATE_ARG_UNION__T (object);

  switch (property_id)
  {
    case PROP_PREDICATE_ARG_UNION__T_LITERAL:
      if (self->literal != NULL)
        g_object_unref (self->literal);
      self->literal = g_value_dup_object (value);
      self->__isset_literal = TRUE;
      break;

    case PROP_PREDICATE_ARG_UNION__T_REF:
      if (self->ref != NULL)
        g_object_unref (self->ref);
      self->ref = g_value_dup_object (value);
      self->__isset_ref = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
predicate_arg_union__t_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  predicate_arg_union_T *self = PREDICATE_ARG_UNION__T (object);

  switch (property_id)
  {
    case PROP_PREDICATE_ARG_UNION__T_LITERAL:
      g_value_set_object (value, self->literal);
      break;

    case PROP_PREDICATE_ARG_UNION__T_REF:
      g_value_set_object (value, self->ref);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
predicate_arg_union__t_instance_init (predicate_arg_union_T * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->literal = g_object_new (TYPE_LITERAL__T, NULL);
  object->__isset_literal = FALSE;
  object->ref = g_object_new (TYPE_COLUMNREF__T, NULL);
  object->__isset_ref = FALSE;
}

static void 
predicate_arg_union__t_finalize (GObject *object)
{
  predicate_arg_union_T *tobject = PREDICATE_ARG_UNION__T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->literal != NULL)
  {
    g_object_unref(tobject->literal);
    tobject->literal = NULL;
  }
  if (tobject->ref != NULL)
  {
    g_object_unref(tobject->ref);
    tobject->ref = NULL;
  }
}

static void
predicate_arg_union__t_class_init (predicate_arg_union_TClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = predicate_arg_union__t_read;
  struct_class->write = predicate_arg_union__t_write;

  gobject_class->finalize = predicate_arg_union__t_finalize;
  gobject_class->get_property = predicate_arg_union__t_get_property;
  gobject_class->set_property = predicate_arg_union__t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PREDICATE_ARG_UNION__T_LITERAL,
     g_param_spec_object ("literal",
                         NULL,
                         NULL,
                         TYPE_LITERAL__T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PREDICATE_ARG_UNION__T_REF,
     g_param_spec_object ("ref",
                         NULL,
                         NULL,
                         TYPE_COLUMNREF__T,
                         G_PARAM_READWRITE));
}

GType
predicate_arg_union__t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (predicate_arg_union_TClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) predicate_arg_union__t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (predicate_arg_union_T),
      0, /* n_preallocs */
      (GInstanceInitFunc) predicate_arg_union__t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "predicate_arg_union_TType",
                                   &type_info, 0);
  }

  return type;
}

enum _columndef_TProperties
{
  PROP_COLUMNDEF__T_0,
  PROP_COLUMNDEF__T_COLUMN_NAME,
  PROP_COLUMNDEF__T_TYPE
};

/* reads a columndef__t object */
static gint32
columndef__t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  columndef_T * this_object = COLUMNDEF__T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->column_name != NULL)
          {
            g_free(this_object->column_name);
            this_object->column_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->column_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_column_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->type, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
columndef__t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  columndef_T * this_object = COLUMNDEF__T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "columndef_T", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "column_name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->column_name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
columndef__t_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  columndef_T *self = COLUMNDEF__T (object);

  switch (property_id)
  {
    case PROP_COLUMNDEF__T_COLUMN_NAME:
      if (self->column_name != NULL)
        g_free (self->column_name);
      self->column_name = g_value_dup_string (value);
      self->__isset_column_name = TRUE;
      break;

    case PROP_COLUMNDEF__T_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
columndef__t_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  columndef_T *self = COLUMNDEF__T (object);

  switch (property_id)
  {
    case PROP_COLUMNDEF__T_COLUMN_NAME:
      g_value_set_string (value, self->column_name);
      break;

    case PROP_COLUMNDEF__T_TYPE:
      g_value_set_int (value, self->type);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
columndef__t_instance_init (columndef_T * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->column_name = NULL;
  object->__isset_column_name = FALSE;
  object->type = 0;
  object->__isset_type = FALSE;
}

static void 
columndef__t_finalize (GObject *object)
{
  columndef_T *tobject = COLUMNDEF__T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->column_name != NULL)
  {
    g_free(tobject->column_name);
    tobject->column_name = NULL;
  }
}

static void
columndef__t_class_init (columndef_TClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = columndef__t_read;
  struct_class->write = columndef__t_write;

  gobject_class->finalize = columndef__t_finalize;
  gobject_class->get_property = columndef__t_get_property;
  gobject_class->set_property = columndef__t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMNDEF__T_COLUMN_NAME,
     g_param_spec_string ("column_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMNDEF__T_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
columndef__t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (columndef_TClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) columndef__t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (columndef_T),
      0, /* n_preallocs */
      (GInstanceInitFunc) columndef__t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "columndef_TType",
                                   &type_info, 0);
  }

  return type;
}

enum _predicate_arg_TProperties
{
  PROP_PREDICATE_ARG__T_0,
  PROP_PREDICATE_ARG__T_TYPE,
  PROP_PREDICATE_ARG__T_ARG
};

/* reads a predicate_arg__t object */
static gint32
predicate_arg__t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  predicate_arg_T * this_object = PREDICATE_ARG__T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast1;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (predicate_arg_type_T)ecast1;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->arg), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_arg = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
predicate_arg__t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  predicate_arg_T * this_object = PREDICATE_ARG__T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "predicate_arg_T", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "arg", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->arg), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
predicate_arg__t_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  predicate_arg_T *self = PREDICATE_ARG__T (object);

  switch (property_id)
  {
    case PROP_PREDICATE_ARG__T_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_PREDICATE_ARG__T_ARG:
      if (self->arg != NULL)
        g_object_unref (self->arg);
      self->arg = g_value_dup_object (value);
      self->__isset_arg = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
predicate_arg__t_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  predicate_arg_T *self = PREDICATE_ARG__T (object);

  switch (property_id)
  {
    case PROP_PREDICATE_ARG__T_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_PREDICATE_ARG__T_ARG:
      g_value_set_object (value, self->arg);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
predicate_arg__t_instance_init (predicate_arg_T * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->arg = g_object_new (TYPE_PREDICATE_ARG_UNION__T, NULL);
  object->__isset_arg = FALSE;
}

static void 
predicate_arg__t_finalize (GObject *object)
{
  predicate_arg_T *tobject = PREDICATE_ARG__T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->arg != NULL)
  {
    g_object_unref(tobject->arg);
    tobject->arg = NULL;
  }
}

static void
predicate_arg__t_class_init (predicate_arg_TClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = predicate_arg__t_read;
  struct_class->write = predicate_arg__t_write;

  gobject_class->finalize = predicate_arg__t_finalize;
  gobject_class->get_property = predicate_arg__t_get_property;
  gobject_class->set_property = predicate_arg__t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PREDICATE_ARG__T_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       1,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PREDICATE_ARG__T_ARG,
     g_param_spec_object ("arg",
                         NULL,
                         NULL,
                         TYPE_PREDICATE_ARG_UNION__T,
                         G_PARAM_READWRITE));
}

GType
predicate_arg__t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (predicate_arg_TClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) predicate_arg__t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (predicate_arg_T),
      0, /* n_preallocs */
      (GInstanceInitFunc) predicate_arg__t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "predicate_arg_TType",
                                   &type_info, 0);
  }

  return type;
}

enum _predicate_TProperties
{
  PROP_PREDICATE__T_0,
  PROP_PREDICATE__T_TYPE,
  PROP_PREDICATE__T_COLUMN,
  PROP_PREDICATE__T_CMP_TYPE,
  PROP_PREDICATE__T_ARG,
  PROP_PREDICATE__T_PREDICATE_OP,
  PROP_PREDICATE__T_LEFT,
  PROP_PREDICATE__T_RIGHT
};

/* reads a predicate__t object */
static gint32
predicate__t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  predicate_T * this_object = PREDICATE__T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast2;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (predicate_type_T)ecast2;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->column), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_column = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->cmp_type, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cmp_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->arg), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_arg = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->predicate_op, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_predicate_op = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              predicate_T * _elem3 = NULL;
              if ( _elem3 != NULL)
              {
                g_object_unref (_elem3);
              }
              _elem3 = g_object_new (TYPE_PREDICATE__T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem3), protocol, error)) < 0)
              {
                g_object_unref (_elem3);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->left, _elem3);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_left = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              predicate_T * _elem4 = NULL;
              if ( _elem4 != NULL)
              {
                g_object_unref (_elem4);
              }
              _elem4 = g_object_new (TYPE_PREDICATE__T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem4), protocol, error)) < 0)
              {
                g_object_unref (_elem4);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->right, _elem4);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_right = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
predicate__t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  predicate_T * this_object = PREDICATE__T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "predicate_T", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_column == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->column), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "cmp_type", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->cmp_type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "arg", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->arg), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "predicate_op", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->predicate_op, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "left", T_LIST, 6, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i5;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->left ? this_object->left->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i5 = 0; i5 < (this_object->left ? this_object->left->len : 0); i5++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->left, i5))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "right", T_LIST, 7, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i6;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->right ? this_object->right->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i6 = 0; i6 < (this_object->right ? this_object->right->len : 0); i6++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->right, i6))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
predicate__t_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  predicate_T *self = PREDICATE__T (object);

  switch (property_id)
  {
    case PROP_PREDICATE__T_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_PREDICATE__T_COLUMN:
      if (self->column != NULL)
        g_object_unref (self->column);
      self->column = g_value_dup_object (value);
      self->__isset_column = TRUE;
      break;

    case PROP_PREDICATE__T_CMP_TYPE:
      self->cmp_type = g_value_get_int (value);
      self->__isset_cmp_type = TRUE;
      break;

    case PROP_PREDICATE__T_ARG:
      if (self->arg != NULL)
        g_object_unref (self->arg);
      self->arg = g_value_dup_object (value);
      self->__isset_arg = TRUE;
      break;

    case PROP_PREDICATE__T_PREDICATE_OP:
      self->predicate_op = g_value_get_int (value);
      self->__isset_predicate_op = TRUE;
      break;

    case PROP_PREDICATE__T_LEFT:
      if (self->left != NULL)
        g_ptr_array_unref (self->left);
      self->left = g_value_dup_boxed (value);
      self->__isset_left = TRUE;
      break;

    case PROP_PREDICATE__T_RIGHT:
      if (self->right != NULL)
        g_ptr_array_unref (self->right);
      self->right = g_value_dup_boxed (value);
      self->__isset_right = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
predicate__t_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  predicate_T *self = PREDICATE__T (object);

  switch (property_id)
  {
    case PROP_PREDICATE__T_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_PREDICATE__T_COLUMN:
      g_value_set_object (value, self->column);
      break;

    case PROP_PREDICATE__T_CMP_TYPE:
      g_value_set_int (value, self->cmp_type);
      break;

    case PROP_PREDICATE__T_ARG:
      g_value_set_object (value, self->arg);
      break;

    case PROP_PREDICATE__T_PREDICATE_OP:
      g_value_set_int (value, self->predicate_op);
      break;

    case PROP_PREDICATE__T_LEFT:
      g_value_set_boxed (value, self->left);
      break;

    case PROP_PREDICATE__T_RIGHT:
      g_value_set_boxed (value, self->right);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
predicate__t_instance_init (predicate_T * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->column = g_object_new (TYPE_COLUMNREF__T, NULL);
  object->__isset_column = FALSE;
  object->cmp_type = 0;
  object->__isset_cmp_type = FALSE;
  object->arg = g_object_new (TYPE_PREDICATE_ARG__T, NULL);
  object->__isset_arg = FALSE;
  object->predicate_op = 0;
  object->__isset_predicate_op = FALSE;
  object->left = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_left = FALSE;
  object->right = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_right = FALSE;
}

static void 
predicate__t_finalize (GObject *object)
{
  predicate_T *tobject = PREDICATE__T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->column != NULL)
  {
    g_object_unref(tobject->column);
    tobject->column = NULL;
  }
  if (tobject->arg != NULL)
  {
    g_object_unref(tobject->arg);
    tobject->arg = NULL;
  }
  if (tobject->left != NULL)
  {
    g_ptr_array_unref (tobject->left);
    tobject->left = NULL;
  }
  if (tobject->right != NULL)
  {
    g_ptr_array_unref (tobject->right);
    tobject->right = NULL;
  }
}

static void
predicate__t_class_init (predicate_TClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = predicate__t_read;
  struct_class->write = predicate__t_write;

  gobject_class->finalize = predicate__t_finalize;
  gobject_class->get_property = predicate__t_get_property;
  gobject_class->set_property = predicate__t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PREDICATE__T_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       2,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PREDICATE__T_COLUMN,
     g_param_spec_object ("column",
                         NULL,
                         NULL,
                         TYPE_COLUMNREF__T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PREDICATE__T_CMP_TYPE,
     g_param_spec_int ("cmp_type",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PREDICATE__T_ARG,
     g_param_spec_object ("arg",
                         NULL,
                         NULL,
                         TYPE_PREDICATE_ARG__T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PREDICATE__T_PREDICATE_OP,
     g_param_spec_int ("predicate_op",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PREDICATE__T_LEFT,
     g_param_spec_boxed ("left",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PREDICATE__T_RIGHT,
     g_param_spec_boxed ("right",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
predicate__t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (predicate_TClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) predicate__t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (predicate_T),
      0, /* n_preallocs */
      (GInstanceInitFunc) predicate__t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "predicate_TType",
                                   &type_info, 0);
  }

  return type;
}

enum _join_stmt_TProperties
{
  PROP_JOIN_STMT__T_0,
  PROP_JOIN_STMT__T_JOIN_ON_TABLE,
  PROP_JOIN_STMT__T_JOIN_PREDICATE
};

/* reads a join_stmt__t object */
static gint32
join_stmt__t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  join_stmt_T * this_object = JOIN_STMT__T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->join_on_table != NULL)
          {
            g_free(this_object->join_on_table);
            this_object->join_on_table = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->join_on_table, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_join_on_table = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->join_predicate), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_join_predicate = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
join_stmt__t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  join_stmt_T * this_object = JOIN_STMT__T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "join_stmt_T", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "join_on_table", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->join_on_table, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_join_predicate == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "join_predicate", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->join_predicate), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
join_stmt__t_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  join_stmt_T *self = JOIN_STMT__T (object);

  switch (property_id)
  {
    case PROP_JOIN_STMT__T_JOIN_ON_TABLE:
      if (self->join_on_table != NULL)
        g_free (self->join_on_table);
      self->join_on_table = g_value_dup_string (value);
      self->__isset_join_on_table = TRUE;
      break;

    case PROP_JOIN_STMT__T_JOIN_PREDICATE:
      if (self->join_predicate != NULL)
        g_object_unref (self->join_predicate);
      self->join_predicate = g_value_dup_object (value);
      self->__isset_join_predicate = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
join_stmt__t_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  join_stmt_T *self = JOIN_STMT__T (object);

  switch (property_id)
  {
    case PROP_JOIN_STMT__T_JOIN_ON_TABLE:
      g_value_set_string (value, self->join_on_table);
      break;

    case PROP_JOIN_STMT__T_JOIN_PREDICATE:
      g_value_set_object (value, self->join_predicate);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
join_stmt__t_instance_init (join_stmt_T * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->join_on_table = NULL;
  object->__isset_join_on_table = FALSE;
  object->join_predicate = g_object_new (TYPE_PREDICATE__T, NULL);
  object->__isset_join_predicate = FALSE;
}

static void 
join_stmt__t_finalize (GObject *object)
{
  join_stmt_T *tobject = JOIN_STMT__T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->join_on_table != NULL)
  {
    g_free(tobject->join_on_table);
    tobject->join_on_table = NULL;
  }
  if (tobject->join_predicate != NULL)
  {
    g_object_unref(tobject->join_predicate);
    tobject->join_predicate = NULL;
  }
}

static void
join_stmt__t_class_init (join_stmt_TClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = join_stmt__t_read;
  struct_class->write = join_stmt__t_write;

  gobject_class->finalize = join_stmt__t_finalize;
  gobject_class->get_property = join_stmt__t_get_property;
  gobject_class->set_property = join_stmt__t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_JOIN_STMT__T_JOIN_ON_TABLE,
     g_param_spec_string ("join_on_table",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_JOIN_STMT__T_JOIN_PREDICATE,
     g_param_spec_object ("join_predicate",
                         NULL,
                         NULL,
                         TYPE_PREDICATE__T,
                         G_PARAM_READWRITE));
}

GType
join_stmt__t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (join_stmt_TClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) join_stmt__t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (join_stmt_T),
      0, /* n_preallocs */
      (GInstanceInitFunc) join_stmt__t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "join_stmt_TType",
                                   &type_info, 0);
  }

  return type;
}

enum _select_stmt_TProperties
{
  PROP_SELECT_STMT__T_0,
  PROP_SELECT_STMT__T_COLUMNS,
  PROP_SELECT_STMT__T_PREDICATE,
  PROP_SELECT_STMT__T_JOIN_STMT
};

/* reads a select_stmt__t object */
static gint32
select_stmt__t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  select_stmt_T * this_object = SELECT_STMT__T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              columnref_T * _elem7 = NULL;
              if ( _elem7 != NULL)
              {
                g_object_unref (_elem7);
              }
              _elem7 = g_object_new (TYPE_COLUMNREF__T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem7), protocol, error)) < 0)
              {
                g_object_unref (_elem7);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->columns, _elem7);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->predicate), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_predicate = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->join_stmt), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_join_stmt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
select_stmt__t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  select_stmt_T * this_object = SELECT_STMT__T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "select_stmt_T", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i8;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i8 = 0; i8 < (this_object->columns ? this_object->columns->len : 0); i8++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->columns, i8))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_predicate == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "predicate", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->predicate), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_join_stmt == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "join_stmt", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->join_stmt), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
select_stmt__t_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  select_stmt_T *self = SELECT_STMT__T (object);

  switch (property_id)
  {
    case PROP_SELECT_STMT__T_COLUMNS:
      if (self->columns != NULL)
        g_ptr_array_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      self->__isset_columns = TRUE;
      break;

    case PROP_SELECT_STMT__T_PREDICATE:
      if (self->predicate != NULL)
        g_object_unref (self->predicate);
      self->predicate = g_value_dup_object (value);
      self->__isset_predicate = TRUE;
      break;

    case PROP_SELECT_STMT__T_JOIN_STMT:
      if (self->join_stmt != NULL)
        g_object_unref (self->join_stmt);
      self->join_stmt = g_value_dup_object (value);
      self->__isset_join_stmt = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
select_stmt__t_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  select_stmt_T *self = SELECT_STMT__T (object);

  switch (property_id)
  {
    case PROP_SELECT_STMT__T_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_SELECT_STMT__T_PREDICATE:
      g_value_set_object (value, self->predicate);
      break;

    case PROP_SELECT_STMT__T_JOIN_STMT:
      g_value_set_object (value, self->join_stmt);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
select_stmt__t_instance_init (select_stmt_T * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->columns = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_columns = FALSE;
  object->predicate = g_object_new (TYPE_PREDICATE__T, NULL);
  object->__isset_predicate = FALSE;
  object->join_stmt = g_object_new (TYPE_JOIN_STMT__T, NULL);
  object->__isset_join_stmt = FALSE;
}

static void 
select_stmt__t_finalize (GObject *object)
{
  select_stmt_T *tobject = SELECT_STMT__T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->predicate != NULL)
  {
    g_object_unref(tobject->predicate);
    tobject->predicate = NULL;
  }
  if (tobject->join_stmt != NULL)
  {
    g_object_unref(tobject->join_stmt);
    tobject->join_stmt = NULL;
  }
}

static void
select_stmt__t_class_init (select_stmt_TClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = select_stmt__t_read;
  struct_class->write = select_stmt__t_write;

  gobject_class->finalize = select_stmt__t_finalize;
  gobject_class->get_property = select_stmt__t_get_property;
  gobject_class->set_property = select_stmt__t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SELECT_STMT__T_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SELECT_STMT__T_PREDICATE,
     g_param_spec_object ("predicate",
                         NULL,
                         NULL,
                         TYPE_PREDICATE__T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SELECT_STMT__T_JOIN_STMT,
     g_param_spec_object ("join_stmt",
                         NULL,
                         NULL,
                         TYPE_JOIN_STMT__T,
                         G_PARAM_READWRITE));
}

GType
select_stmt__t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (select_stmt_TClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) select_stmt__t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (select_stmt_T),
      0, /* n_preallocs */
      (GInstanceInitFunc) select_stmt__t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "select_stmt_TType",
                                   &type_info, 0);
  }

  return type;
}

enum _insert_stmt_TProperties
{
  PROP_INSERT_STMT__T_0,
  PROP_INSERT_STMT__T_COLUMNS,
  PROP_INSERT_STMT__T_LITERALS
};

/* reads a insert_stmt__t object */
static gint32
insert_stmt__t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  insert_stmt_T * this_object = INSERT_STMT__T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              columnref_T * _elem9 = NULL;
              if ( _elem9 != NULL)
              {
                g_object_unref (_elem9);
              }
              _elem9 = g_object_new (TYPE_COLUMNREF__T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem9), protocol, error)) < 0)
              {
                g_object_unref (_elem9);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->columns, _elem9);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              literal_T * _elem10 = NULL;
              if ( _elem10 != NULL)
              {
                g_object_unref (_elem10);
              }
              _elem10 = g_object_new (TYPE_LITERAL__T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem10), protocol, error)) < 0)
              {
                g_object_unref (_elem10);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->literals, _elem10);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_literals = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
insert_stmt__t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  insert_stmt_T * this_object = INSERT_STMT__T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "insert_stmt_T", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i11;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i11 = 0; i11 < (this_object->columns ? this_object->columns->len : 0); i11++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->columns, i11))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "literals", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i12;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->literals ? this_object->literals->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i12 = 0; i12 < (this_object->literals ? this_object->literals->len : 0); i12++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->literals, i12))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
insert_stmt__t_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  insert_stmt_T *self = INSERT_STMT__T (object);

  switch (property_id)
  {
    case PROP_INSERT_STMT__T_COLUMNS:
      if (self->columns != NULL)
        g_ptr_array_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      self->__isset_columns = TRUE;
      break;

    case PROP_INSERT_STMT__T_LITERALS:
      if (self->literals != NULL)
        g_ptr_array_unref (self->literals);
      self->literals = g_value_dup_boxed (value);
      self->__isset_literals = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
insert_stmt__t_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  insert_stmt_T *self = INSERT_STMT__T (object);

  switch (property_id)
  {
    case PROP_INSERT_STMT__T_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_INSERT_STMT__T_LITERALS:
      g_value_set_boxed (value, self->literals);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
insert_stmt__t_instance_init (insert_stmt_T * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->columns = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_columns = FALSE;
  object->literals = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_literals = FALSE;
}

static void 
insert_stmt__t_finalize (GObject *object)
{
  insert_stmt_T *tobject = INSERT_STMT__T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->literals != NULL)
  {
    g_ptr_array_unref (tobject->literals);
    tobject->literals = NULL;
  }
}

static void
insert_stmt__t_class_init (insert_stmt_TClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = insert_stmt__t_read;
  struct_class->write = insert_stmt__t_write;

  gobject_class->finalize = insert_stmt__t_finalize;
  gobject_class->get_property = insert_stmt__t_get_property;
  gobject_class->set_property = insert_stmt__t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_INSERT_STMT__T_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_INSERT_STMT__T_LITERALS,
     g_param_spec_boxed ("literals",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
insert_stmt__t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (insert_stmt_TClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) insert_stmt__t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (insert_stmt_T),
      0, /* n_preallocs */
      (GInstanceInitFunc) insert_stmt__t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "insert_stmt_TType",
                                   &type_info, 0);
  }

  return type;
}

enum _create_stmt_TProperties
{
  PROP_CREATE_STMT__T_0,
  PROP_CREATE_STMT__T_DEFS
};

/* reads a create_stmt__t object */
static gint32
create_stmt__t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  create_stmt_T * this_object = CREATE_STMT__T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              columndef_T * _elem13 = NULL;
              if ( _elem13 != NULL)
              {
                g_object_unref (_elem13);
              }
              _elem13 = g_object_new (TYPE_COLUMNDEF__T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem13), protocol, error)) < 0)
              {
                g_object_unref (_elem13);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->defs, _elem13);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_defs = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
create_stmt__t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  create_stmt_T * this_object = CREATE_STMT__T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "create_stmt_T", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "defs", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i14;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->defs ? this_object->defs->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i14 = 0; i14 < (this_object->defs ? this_object->defs->len : 0); i14++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->defs, i14))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
create_stmt__t_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  create_stmt_T *self = CREATE_STMT__T (object);

  switch (property_id)
  {
    case PROP_CREATE_STMT__T_DEFS:
      if (self->defs != NULL)
        g_ptr_array_unref (self->defs);
      self->defs = g_value_dup_boxed (value);
      self->__isset_defs = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
create_stmt__t_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  create_stmt_T *self = CREATE_STMT__T (object);

  switch (property_id)
  {
    case PROP_CREATE_STMT__T_DEFS:
      g_value_set_boxed (value, self->defs);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
create_stmt__t_instance_init (create_stmt_T * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->defs = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_defs = FALSE;
}

static void 
create_stmt__t_finalize (GObject *object)
{
  create_stmt_T *tobject = CREATE_STMT__T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->defs != NULL)
  {
    g_ptr_array_unref (tobject->defs);
    tobject->defs = NULL;
  }
}

static void
create_stmt__t_class_init (create_stmt_TClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = create_stmt__t_read;
  struct_class->write = create_stmt__t_write;

  gobject_class->finalize = create_stmt__t_finalize;
  gobject_class->get_property = create_stmt__t_get_property;
  gobject_class->set_property = create_stmt__t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CREATE_STMT__T_DEFS,
     g_param_spec_boxed ("defs",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
create_stmt__t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (create_stmt_TClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) create_stmt__t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (create_stmt_T),
      0, /* n_preallocs */
      (GInstanceInitFunc) create_stmt__t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "create_stmt_TType",
                                   &type_info, 0);
  }

  return type;
}

enum _set_value_TProperties
{
  PROP_SET_VALUE__T_0,
  PROP_SET_VALUE__T_COL,
  PROP_SET_VALUE__T_LIT
};

/* reads a set_value__t object */
static gint32
set_value__t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  set_value_T * this_object = SET_VALUE__T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->col), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_col = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->lit), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_lit = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
set_value__t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  set_value_T * this_object = SET_VALUE__T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "set_value_T", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "col", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->col), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "lit", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->lit), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
set_value__t_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  set_value_T *self = SET_VALUE__T (object);

  switch (property_id)
  {
    case PROP_SET_VALUE__T_COL:
      if (self->col != NULL)
        g_object_unref (self->col);
      self->col = g_value_dup_object (value);
      self->__isset_col = TRUE;
      break;

    case PROP_SET_VALUE__T_LIT:
      if (self->lit != NULL)
        g_object_unref (self->lit);
      self->lit = g_value_dup_object (value);
      self->__isset_lit = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
set_value__t_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  set_value_T *self = SET_VALUE__T (object);

  switch (property_id)
  {
    case PROP_SET_VALUE__T_COL:
      g_value_set_object (value, self->col);
      break;

    case PROP_SET_VALUE__T_LIT:
      g_value_set_object (value, self->lit);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
set_value__t_instance_init (set_value_T * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->col = g_object_new (TYPE_COLUMNREF__T, NULL);
  object->__isset_col = FALSE;
  object->lit = g_object_new (TYPE_LITERAL__T, NULL);
  object->__isset_lit = FALSE;
}

static void 
set_value__t_finalize (GObject *object)
{
  set_value_T *tobject = SET_VALUE__T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->col != NULL)
  {
    g_object_unref(tobject->col);
    tobject->col = NULL;
  }
  if (tobject->lit != NULL)
  {
    g_object_unref(tobject->lit);
    tobject->lit = NULL;
  }
}

static void
set_value__t_class_init (set_value_TClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = set_value__t_read;
  struct_class->write = set_value__t_write;

  gobject_class->finalize = set_value__t_finalize;
  gobject_class->get_property = set_value__t_get_property;
  gobject_class->set_property = set_value__t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SET_VALUE__T_COL,
     g_param_spec_object ("col",
                         NULL,
                         NULL,
                         TYPE_COLUMNREF__T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SET_VALUE__T_LIT,
     g_param_spec_object ("lit",
                         NULL,
                         NULL,
                         TYPE_LITERAL__T,
                         G_PARAM_READWRITE));
}

GType
set_value__t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (set_value_TClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) set_value__t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (set_value_T),
      0, /* n_preallocs */
      (GInstanceInitFunc) set_value__t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "set_value_TType",
                                   &type_info, 0);
  }

  return type;
}

enum _update_stmt_TProperties
{
  PROP_UPDATE_STMT__T_0,
  PROP_UPDATE_STMT__T_SET_VALUE_LIST,
  PROP_UPDATE_STMT__T_PREDICATE
};

/* reads a update_stmt__t object */
static gint32
update_stmt__t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  update_stmt_T * this_object = UPDATE_STMT__T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              set_value_T * _elem15 = NULL;
              if ( _elem15 != NULL)
              {
                g_object_unref (_elem15);
              }
              _elem15 = g_object_new (TYPE_SET_VALUE__T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem15), protocol, error)) < 0)
              {
                g_object_unref (_elem15);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->set_value_list, _elem15);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_set_value_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->predicate), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_predicate = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
update_stmt__t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  update_stmt_T * this_object = UPDATE_STMT__T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "update_stmt_T", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "set_value_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i16;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->set_value_list ? this_object->set_value_list->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i16 = 0; i16 < (this_object->set_value_list ? this_object->set_value_list->len : 0); i16++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->set_value_list, i16))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_predicate == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "predicate", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->predicate), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
update_stmt__t_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  update_stmt_T *self = UPDATE_STMT__T (object);

  switch (property_id)
  {
    case PROP_UPDATE_STMT__T_SET_VALUE_LIST:
      if (self->set_value_list != NULL)
        g_ptr_array_unref (self->set_value_list);
      self->set_value_list = g_value_dup_boxed (value);
      self->__isset_set_value_list = TRUE;
      break;

    case PROP_UPDATE_STMT__T_PREDICATE:
      if (self->predicate != NULL)
        g_object_unref (self->predicate);
      self->predicate = g_value_dup_object (value);
      self->__isset_predicate = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
update_stmt__t_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  update_stmt_T *self = UPDATE_STMT__T (object);

  switch (property_id)
  {
    case PROP_UPDATE_STMT__T_SET_VALUE_LIST:
      g_value_set_boxed (value, self->set_value_list);
      break;

    case PROP_UPDATE_STMT__T_PREDICATE:
      g_value_set_object (value, self->predicate);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
update_stmt__t_instance_init (update_stmt_T * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->set_value_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_set_value_list = FALSE;
  object->predicate = g_object_new (TYPE_PREDICATE__T, NULL);
  object->__isset_predicate = FALSE;
}

static void 
update_stmt__t_finalize (GObject *object)
{
  update_stmt_T *tobject = UPDATE_STMT__T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->set_value_list != NULL)
  {
    g_ptr_array_unref (tobject->set_value_list);
    tobject->set_value_list = NULL;
  }
  if (tobject->predicate != NULL)
  {
    g_object_unref(tobject->predicate);
    tobject->predicate = NULL;
  }
}

static void
update_stmt__t_class_init (update_stmt_TClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = update_stmt__t_read;
  struct_class->write = update_stmt__t_write;

  gobject_class->finalize = update_stmt__t_finalize;
  gobject_class->get_property = update_stmt__t_get_property;
  gobject_class->set_property = update_stmt__t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_STMT__T_SET_VALUE_LIST,
     g_param_spec_boxed ("set_value_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_STMT__T_PREDICATE,
     g_param_spec_object ("predicate",
                         NULL,
                         NULL,
                         TYPE_PREDICATE__T,
                         G_PARAM_READWRITE));
}

GType
update_stmt__t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (update_stmt_TClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) update_stmt__t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (update_stmt_T),
      0, /* n_preallocs */
      (GInstanceInitFunc) update_stmt__t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "update_stmt_TType",
                                   &type_info, 0);
  }

  return type;
}

enum _delete_stmt_TProperties
{
  PROP_DELETE_STMT__T_0,
  PROP_DELETE_STMT__T_PREDICATE
};

/* reads a delete_stmt__t object */
static gint32
delete_stmt__t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  delete_stmt_T * this_object = DELETE_STMT__T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->predicate), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_predicate = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
delete_stmt__t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  delete_stmt_T * this_object = DELETE_STMT__T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "delete_stmt_T", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_predicate == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "predicate", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->predicate), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
delete_stmt__t_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  delete_stmt_T *self = DELETE_STMT__T (object);

  switch (property_id)
  {
    case PROP_DELETE_STMT__T_PREDICATE:
      if (self->predicate != NULL)
        g_object_unref (self->predicate);
      self->predicate = g_value_dup_object (value);
      self->__isset_predicate = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
delete_stmt__t_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  delete_stmt_T *self = DELETE_STMT__T (object);

  switch (property_id)
  {
    case PROP_DELETE_STMT__T_PREDICATE:
      g_value_set_object (value, self->predicate);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
delete_stmt__t_instance_init (delete_stmt_T * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->predicate = g_object_new (TYPE_PREDICATE__T, NULL);
  object->__isset_predicate = FALSE;
}

static void 
delete_stmt__t_finalize (GObject *object)
{
  delete_stmt_T *tobject = DELETE_STMT__T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->predicate != NULL)
  {
    g_object_unref(tobject->predicate);
    tobject->predicate = NULL;
  }
}

static void
delete_stmt__t_class_init (delete_stmt_TClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = delete_stmt__t_read;
  struct_class->write = delete_stmt__t_write;

  gobject_class->finalize = delete_stmt__t_finalize;
  gobject_class->get_property = delete_stmt__t_get_property;
  gobject_class->set_property = delete_stmt__t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DELETE_STMT__T_PREDICATE,
     g_param_spec_object ("predicate",
                         NULL,
                         NULL,
                         TYPE_PREDICATE__T,
                         G_PARAM_READWRITE));
}

GType
delete_stmt__t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (delete_stmt_TClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) delete_stmt__t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (delete_stmt_T),
      0, /* n_preallocs */
      (GInstanceInitFunc) delete_stmt__t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "delete_stmt_TType",
                                   &type_info, 0);
  }

  return type;
}

enum _statement_union_TProperties
{
  PROP_STATEMENT_UNION__T_0,
  PROP_STATEMENT_UNION__T_SELECT_STMT,
  PROP_STATEMENT_UNION__T_INSERT_STMT,
  PROP_STATEMENT_UNION__T_UPDATE_STMT,
  PROP_STATEMENT_UNION__T_CREATE_STMT,
  PROP_STATEMENT_UNION__T_DELETE_STMT
};

/* reads a statement_union__t object */
static gint32
statement_union__t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  statement_union_T * this_object = STATEMENT_UNION__T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->select_stmt), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_select_stmt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->insert_stmt), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_insert_stmt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->update_stmt), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_update_stmt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->create_stmt), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_create_stmt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->delete_stmt), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_delete_stmt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
statement_union__t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  statement_union_T * this_object = STATEMENT_UNION__T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "statement_union_T", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_select_stmt == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "select_stmt", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->select_stmt), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_insert_stmt == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "insert_stmt", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->insert_stmt), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_update_stmt == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "update_stmt", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->update_stmt), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_create_stmt == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "create_stmt", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->create_stmt), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_delete_stmt == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "delete_stmt", T_STRUCT, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->delete_stmt), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
statement_union__t_set_property (GObject *object,
                                 guint property_id,
                                 const GValue *value,
                                 GParamSpec *pspec)
{
  statement_union_T *self = STATEMENT_UNION__T (object);

  switch (property_id)
  {
    case PROP_STATEMENT_UNION__T_SELECT_STMT:
      if (self->select_stmt != NULL)
        g_object_unref (self->select_stmt);
      self->select_stmt = g_value_dup_object (value);
      self->__isset_select_stmt = TRUE;
      break;

    case PROP_STATEMENT_UNION__T_INSERT_STMT:
      if (self->insert_stmt != NULL)
        g_object_unref (self->insert_stmt);
      self->insert_stmt = g_value_dup_object (value);
      self->__isset_insert_stmt = TRUE;
      break;

    case PROP_STATEMENT_UNION__T_UPDATE_STMT:
      if (self->update_stmt != NULL)
        g_object_unref (self->update_stmt);
      self->update_stmt = g_value_dup_object (value);
      self->__isset_update_stmt = TRUE;
      break;

    case PROP_STATEMENT_UNION__T_CREATE_STMT:
      if (self->create_stmt != NULL)
        g_object_unref (self->create_stmt);
      self->create_stmt = g_value_dup_object (value);
      self->__isset_create_stmt = TRUE;
      break;

    case PROP_STATEMENT_UNION__T_DELETE_STMT:
      if (self->delete_stmt != NULL)
        g_object_unref (self->delete_stmt);
      self->delete_stmt = g_value_dup_object (value);
      self->__isset_delete_stmt = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
statement_union__t_get_property (GObject *object,
                                 guint property_id,
                                 GValue *value,
                                 GParamSpec *pspec)
{
  statement_union_T *self = STATEMENT_UNION__T (object);

  switch (property_id)
  {
    case PROP_STATEMENT_UNION__T_SELECT_STMT:
      g_value_set_object (value, self->select_stmt);
      break;

    case PROP_STATEMENT_UNION__T_INSERT_STMT:
      g_value_set_object (value, self->insert_stmt);
      break;

    case PROP_STATEMENT_UNION__T_UPDATE_STMT:
      g_value_set_object (value, self->update_stmt);
      break;

    case PROP_STATEMENT_UNION__T_CREATE_STMT:
      g_value_set_object (value, self->create_stmt);
      break;

    case PROP_STATEMENT_UNION__T_DELETE_STMT:
      g_value_set_object (value, self->delete_stmt);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
statement_union__t_instance_init (statement_union_T * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->select_stmt = g_object_new (TYPE_SELECT_STMT__T, NULL);
  object->__isset_select_stmt = FALSE;
  object->insert_stmt = g_object_new (TYPE_INSERT_STMT__T, NULL);
  object->__isset_insert_stmt = FALSE;
  object->update_stmt = g_object_new (TYPE_UPDATE_STMT__T, NULL);
  object->__isset_update_stmt = FALSE;
  object->create_stmt = g_object_new (TYPE_CREATE_STMT__T, NULL);
  object->__isset_create_stmt = FALSE;
  object->delete_stmt = g_object_new (TYPE_DELETE_STMT__T, NULL);
  object->__isset_delete_stmt = FALSE;
}

static void 
statement_union__t_finalize (GObject *object)
{
  statement_union_T *tobject = STATEMENT_UNION__T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->select_stmt != NULL)
  {
    g_object_unref(tobject->select_stmt);
    tobject->select_stmt = NULL;
  }
  if (tobject->insert_stmt != NULL)
  {
    g_object_unref(tobject->insert_stmt);
    tobject->insert_stmt = NULL;
  }
  if (tobject->update_stmt != NULL)
  {
    g_object_unref(tobject->update_stmt);
    tobject->update_stmt = NULL;
  }
  if (tobject->create_stmt != NULL)
  {
    g_object_unref(tobject->create_stmt);
    tobject->create_stmt = NULL;
  }
  if (tobject->delete_stmt != NULL)
  {
    g_object_unref(tobject->delete_stmt);
    tobject->delete_stmt = NULL;
  }
}

static void
statement_union__t_class_init (statement_union_TClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = statement_union__t_read;
  struct_class->write = statement_union__t_write;

  gobject_class->finalize = statement_union__t_finalize;
  gobject_class->get_property = statement_union__t_get_property;
  gobject_class->set_property = statement_union__t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_STATEMENT_UNION__T_SELECT_STMT,
     g_param_spec_object ("select_stmt",
                         NULL,
                         NULL,
                         TYPE_SELECT_STMT__T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STATEMENT_UNION__T_INSERT_STMT,
     g_param_spec_object ("insert_stmt",
                         NULL,
                         NULL,
                         TYPE_INSERT_STMT__T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STATEMENT_UNION__T_UPDATE_STMT,
     g_param_spec_object ("update_stmt",
                         NULL,
                         NULL,
                         TYPE_UPDATE_STMT__T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STATEMENT_UNION__T_CREATE_STMT,
     g_param_spec_object ("create_stmt",
                         NULL,
                         NULL,
                         TYPE_CREATE_STMT__T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STATEMENT_UNION__T_DELETE_STMT,
     g_param_spec_object ("delete_stmt",
                         NULL,
                         NULL,
                         TYPE_DELETE_STMT__T,
                         G_PARAM_READWRITE));
}

GType
statement_union__t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (statement_union_TClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) statement_union__t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (statement_union_T),
      0, /* n_preallocs */
      (GInstanceInitFunc) statement_union__t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "statement_union_TType",
                                   &type_info, 0);
  }

  return type;
}

enum _statement_TProperties
{
  PROP_STATEMENT__T_0,
  PROP_STATEMENT__T_STMT,
  PROP_STATEMENT__T_STMT_TYPE,
  PROP_STATEMENT__T_TABLE_NAME
};

/* reads a statement__t object */
static gint32
statement__t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  statement_T * this_object = STATEMENT__T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->stmt), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_stmt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->stmt_type, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_stmt_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->table_name != NULL)
          {
            g_free(this_object->table_name);
            this_object->table_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->table_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_table_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
statement__t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  statement_T * this_object = STATEMENT__T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "statement_T", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "stmt", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->stmt), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "stmt_type", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->stmt_type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "table_name", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->table_name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
statement__t_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  statement_T *self = STATEMENT__T (object);

  switch (property_id)
  {
    case PROP_STATEMENT__T_STMT:
      if (self->stmt != NULL)
        g_object_unref (self->stmt);
      self->stmt = g_value_dup_object (value);
      self->__isset_stmt = TRUE;
      break;

    case PROP_STATEMENT__T_STMT_TYPE:
      self->stmt_type = g_value_get_int (value);
      self->__isset_stmt_type = TRUE;
      break;

    case PROP_STATEMENT__T_TABLE_NAME:
      if (self->table_name != NULL)
        g_free (self->table_name);
      self->table_name = g_value_dup_string (value);
      self->__isset_table_name = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
statement__t_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  statement_T *self = STATEMENT__T (object);

  switch (property_id)
  {
    case PROP_STATEMENT__T_STMT:
      g_value_set_object (value, self->stmt);
      break;

    case PROP_STATEMENT__T_STMT_TYPE:
      g_value_set_int (value, self->stmt_type);
      break;

    case PROP_STATEMENT__T_TABLE_NAME:
      g_value_set_string (value, self->table_name);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
statement__t_instance_init (statement_T * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->stmt = g_object_new (TYPE_STATEMENT_UNION__T, NULL);
  object->__isset_stmt = FALSE;
  object->stmt_type = 0;
  object->__isset_stmt_type = FALSE;
  object->table_name = NULL;
  object->__isset_table_name = FALSE;
}

static void 
statement__t_finalize (GObject *object)
{
  statement_T *tobject = STATEMENT__T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->stmt != NULL)
  {
    g_object_unref(tobject->stmt);
    tobject->stmt = NULL;
  }
  if (tobject->table_name != NULL)
  {
    g_free(tobject->table_name);
    tobject->table_name = NULL;
  }
}

static void
statement__t_class_init (statement_TClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = statement__t_read;
  struct_class->write = statement__t_write;

  gobject_class->finalize = statement__t_finalize;
  gobject_class->get_property = statement__t_get_property;
  gobject_class->set_property = statement__t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_STATEMENT__T_STMT,
     g_param_spec_object ("stmt",
                         NULL,
                         NULL,
                         TYPE_STATEMENT_UNION__T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STATEMENT__T_STMT_TYPE,
     g_param_spec_int ("stmt_type",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STATEMENT__T_TABLE_NAME,
     g_param_spec_string ("table_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
statement__t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (statement_TClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) statement__t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (statement_T),
      0, /* n_preallocs */
      (GInstanceInitFunc) statement__t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "statement_TType",
                                   &type_info, 0);
  }

  return type;
}

enum _row_TProperties
{
  PROP_ROW__T_0,
  PROP_ROW__T_VALUE
};

/* reads a row__t object */
static gint32
row__t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  row_T * this_object = ROW__T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              literal_T * _elem17 = NULL;
              if ( _elem17 != NULL)
              {
                g_object_unref (_elem17);
              }
              _elem17 = g_object_new (TYPE_LITERAL__T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem17), protocol, error)) < 0)
              {
                g_object_unref (_elem17);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->value, _elem17);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
row__t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  row_T * this_object = ROW__T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "row_T", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i18;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->value ? this_object->value->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i18 = 0; i18 < (this_object->value ? this_object->value->len : 0); i18++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->value, i18))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
row__t_set_property (GObject *object,
                     guint property_id,
                     const GValue *value,
                     GParamSpec *pspec)
{
  row_T *self = ROW__T (object);

  switch (property_id)
  {
    case PROP_ROW__T_VALUE:
      if (self->value != NULL)
        g_ptr_array_unref (self->value);
      self->value = g_value_dup_boxed (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
row__t_get_property (GObject *object,
                     guint property_id,
                     GValue *value,
                     GParamSpec *pspec)
{
  row_T *self = ROW__T (object);

  switch (property_id)
  {
    case PROP_ROW__T_VALUE:
      g_value_set_boxed (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
row__t_instance_init (row_T * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->value = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_value = FALSE;
}

static void 
row__t_finalize (GObject *object)
{
  row_T *tobject = ROW__T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->value != NULL)
  {
    g_ptr_array_unref (tobject->value);
    tobject->value = NULL;
  }
}

static void
row__t_class_init (row_TClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = row__t_read;
  struct_class->write = row__t_write;

  gobject_class->finalize = row__t_finalize;
  gobject_class->get_property = row__t_get_property;
  gobject_class->set_property = row__t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_ROW__T_VALUE,
     g_param_spec_boxed ("value",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
row__t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (row_TClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) row__t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (row_T),
      0, /* n_preallocs */
      (GInstanceInitFunc) row__t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "row_TType",
                                   &type_info, 0);
  }

  return type;
}

enum _item_list_TProperties
{
  PROP_ITEM_LIST__T_0,
  PROP_ITEM_LIST__T_SCHEMA,
  PROP_ITEM_LIST__T_ROWS
};

/* reads a item_list__t object */
static gint32
item_list__t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  item_list_T * this_object = ITEM_LIST__T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              columnref_T * _elem19 = NULL;
              if ( _elem19 != NULL)
              {
                g_object_unref (_elem19);
              }
              _elem19 = g_object_new (TYPE_COLUMNREF__T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem19), protocol, error)) < 0)
              {
                g_object_unref (_elem19);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->schema, _elem19);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_schema = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              row_T * _elem20 = NULL;
              if ( _elem20 != NULL)
              {
                g_object_unref (_elem20);
              }
              _elem20 = g_object_new (TYPE_ROW__T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem20), protocol, error)) < 0)
              {
                g_object_unref (_elem20);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->rows, _elem20);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_rows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
item_list__t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  item_list_T * this_object = ITEM_LIST__T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "item_list_T", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "schema", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i21;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->schema ? this_object->schema->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i21 = 0; i21 < (this_object->schema ? this_object->schema->len : 0); i21++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->schema, i21))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rows", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i22;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->rows ? this_object->rows->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i22 = 0; i22 < (this_object->rows ? this_object->rows->len : 0); i22++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->rows, i22))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
item_list__t_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  item_list_T *self = ITEM_LIST__T (object);

  switch (property_id)
  {
    case PROP_ITEM_LIST__T_SCHEMA:
      if (self->schema != NULL)
        g_ptr_array_unref (self->schema);
      self->schema = g_value_dup_boxed (value);
      self->__isset_schema = TRUE;
      break;

    case PROP_ITEM_LIST__T_ROWS:
      if (self->rows != NULL)
        g_ptr_array_unref (self->rows);
      self->rows = g_value_dup_boxed (value);
      self->__isset_rows = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
item_list__t_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  item_list_T *self = ITEM_LIST__T (object);

  switch (property_id)
  {
    case PROP_ITEM_LIST__T_SCHEMA:
      g_value_set_boxed (value, self->schema);
      break;

    case PROP_ITEM_LIST__T_ROWS:
      g_value_set_boxed (value, self->rows);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
item_list__t_instance_init (item_list_T * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->schema = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_schema = FALSE;
  object->rows = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_rows = FALSE;
}

static void 
item_list__t_finalize (GObject *object)
{
  item_list_T *tobject = ITEM_LIST__T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schema != NULL)
  {
    g_ptr_array_unref (tobject->schema);
    tobject->schema = NULL;
  }
  if (tobject->rows != NULL)
  {
    g_ptr_array_unref (tobject->rows);
    tobject->rows = NULL;
  }
}

static void
item_list__t_class_init (item_list_TClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = item_list__t_read;
  struct_class->write = item_list__t_write;

  gobject_class->finalize = item_list__t_finalize;
  gobject_class->get_property = item_list__t_get_property;
  gobject_class->set_property = item_list__t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_ITEM_LIST__T_SCHEMA,
     g_param_spec_boxed ("schema",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ITEM_LIST__T_ROWS,
     g_param_spec_boxed ("rows",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
item_list__t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (item_list_TClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) item_list__t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (item_list_T),
      0, /* n_preallocs */
      (GInstanceInitFunc) item_list__t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "item_list_TType",
                                   &type_info, 0);
  }

  return type;
}

enum _server_response_TProperties
{
  PROP_SERVER_RESPONSE__T_0,
  PROP_SERVER_RESPONSE__T_STATUS,
  PROP_SERVER_RESPONSE__T_MSG,
  PROP_SERVER_RESPONSE__T_ITEMS
};

/* reads a server_response__t object */
static gint32
server_response__t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  server_response_T * this_object = SERVER_RESPONSE__T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast23;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast23, error)) < 0)
            return -1;
          xfer += ret;
          this_object->status = (status_code_T)ecast23;
          this_object->__isset_status = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->msg != NULL)
          {
            g_free(this_object->msg);
            this_object->msg = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->msg, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_msg = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->items), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_items = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
server_response__t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  server_response_T * this_object = SERVER_RESPONSE__T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "server_response_T", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "status", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->status, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "msg", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->msg, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_items == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "items", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->items), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
server_response__t_set_property (GObject *object,
                                 guint property_id,
                                 const GValue *value,
                                 GParamSpec *pspec)
{
  server_response_T *self = SERVER_RESPONSE__T (object);

  switch (property_id)
  {
    case PROP_SERVER_RESPONSE__T_STATUS:
      self->status = g_value_get_int (value);
      self->__isset_status = TRUE;
      break;

    case PROP_SERVER_RESPONSE__T_MSG:
      if (self->msg != NULL)
        g_free (self->msg);
      self->msg = g_value_dup_string (value);
      self->__isset_msg = TRUE;
      break;

    case PROP_SERVER_RESPONSE__T_ITEMS:
      if (self->items != NULL)
        g_object_unref (self->items);
      self->items = g_value_dup_object (value);
      self->__isset_items = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
server_response__t_get_property (GObject *object,
                                 guint property_id,
                                 GValue *value,
                                 GParamSpec *pspec)
{
  server_response_T *self = SERVER_RESPONSE__T (object);

  switch (property_id)
  {
    case PROP_SERVER_RESPONSE__T_STATUS:
      g_value_set_int (value, self->status);
      break;

    case PROP_SERVER_RESPONSE__T_MSG:
      g_value_set_string (value, self->msg);
      break;

    case PROP_SERVER_RESPONSE__T_ITEMS:
      g_value_set_object (value, self->items);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
server_response__t_instance_init (server_response_T * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_status = FALSE;
  object->msg = NULL;
  object->__isset_msg = FALSE;
  object->items = g_object_new (TYPE_ITEM_LIST__T, NULL);
  object->__isset_items = FALSE;
}

static void 
server_response__t_finalize (GObject *object)
{
  server_response_T *tobject = SERVER_RESPONSE__T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->msg != NULL)
  {
    g_free(tobject->msg);
    tobject->msg = NULL;
  }
  if (tobject->items != NULL)
  {
    g_object_unref(tobject->items);
    tobject->items = NULL;
  }
}

static void
server_response__t_class_init (server_response_TClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = server_response__t_read;
  struct_class->write = server_response__t_write;

  gobject_class->finalize = server_response__t_finalize;
  gobject_class->get_property = server_response__t_get_property;
  gobject_class->set_property = server_response__t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVER_RESPONSE__T_STATUS,
     g_param_spec_int ("status",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVER_RESPONSE__T_MSG,
     g_param_spec_string ("msg",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVER_RESPONSE__T_ITEMS,
     g_param_spec_object ("items",
                         NULL,
                         NULL,
                         TYPE_ITEM_LIST__T,
                         G_PARAM_READWRITE));
}

GType
server_response__t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (server_response_TClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) server_response__t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (server_response_T),
      0, /* n_preallocs */
      (GInstanceInitFunc) server_response__t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "server_response_TType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _data_exchange_serviceExecuteArgsProperties
{
  PROP_DATA_EXCHANGE_SERVICE_EXECUTE_ARGS_0,
  PROP_DATA_EXCHANGE_SERVICE_EXECUTE_ARGS_STMT
};

/* reads a data_exchange_service_execute_args object */
static gint32
data_exchange_service_execute_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  data_exchange_serviceExecuteArgs * this_object = DATA_EXCHANGE_SERVICE_EXECUTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->stmt), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_stmt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
data_exchange_service_execute_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  data_exchange_serviceExecuteArgs * this_object = DATA_EXCHANGE_SERVICE_EXECUTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "data_exchange_serviceExecuteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "stmt", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->stmt), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
data_exchange_service_execute_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  data_exchange_serviceExecuteArgs *self = DATA_EXCHANGE_SERVICE_EXECUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_DATA_EXCHANGE_SERVICE_EXECUTE_ARGS_STMT:
      if (self->stmt != NULL)
        g_object_unref (self->stmt);
      self->stmt = g_value_dup_object (value);
      self->__isset_stmt = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
data_exchange_service_execute_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  data_exchange_serviceExecuteArgs *self = DATA_EXCHANGE_SERVICE_EXECUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_DATA_EXCHANGE_SERVICE_EXECUTE_ARGS_STMT:
      g_value_set_object (value, self->stmt);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
data_exchange_service_execute_args_instance_init (data_exchange_serviceExecuteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->stmt = g_object_new (TYPE_STATEMENT__T, NULL);
  object->__isset_stmt = FALSE;
}

static void 
data_exchange_service_execute_args_finalize (GObject *object)
{
  data_exchange_serviceExecuteArgs *tobject = DATA_EXCHANGE_SERVICE_EXECUTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->stmt != NULL)
  {
    g_object_unref(tobject->stmt);
    tobject->stmt = NULL;
  }
}

static void
data_exchange_service_execute_args_class_init (data_exchange_serviceExecuteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = data_exchange_service_execute_args_read;
  struct_class->write = data_exchange_service_execute_args_write;

  gobject_class->finalize = data_exchange_service_execute_args_finalize;
  gobject_class->get_property = data_exchange_service_execute_args_get_property;
  gobject_class->set_property = data_exchange_service_execute_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DATA_EXCHANGE_SERVICE_EXECUTE_ARGS_STMT,
     g_param_spec_object ("stmt",
                         NULL,
                         NULL,
                         TYPE_STATEMENT__T,
                         G_PARAM_READWRITE));
}

GType
data_exchange_service_execute_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (data_exchange_serviceExecuteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) data_exchange_service_execute_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (data_exchange_serviceExecuteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) data_exchange_service_execute_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "data_exchange_serviceExecuteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _data_exchange_serviceExecuteResultProperties
{
  PROP_DATA_EXCHANGE_SERVICE_EXECUTE_RESULT_0,
  PROP_DATA_EXCHANGE_SERVICE_EXECUTE_RESULT_SUCCESS
};

/* reads a data_exchange_service_execute_result object */
static gint32
data_exchange_service_execute_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  data_exchange_serviceExecuteResult * this_object = DATA_EXCHANGE_SERVICE_EXECUTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
data_exchange_service_execute_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  data_exchange_serviceExecuteResult * this_object = DATA_EXCHANGE_SERVICE_EXECUTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "data_exchange_serviceExecuteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
data_exchange_service_execute_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  data_exchange_serviceExecuteResult *self = DATA_EXCHANGE_SERVICE_EXECUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_DATA_EXCHANGE_SERVICE_EXECUTE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
data_exchange_service_execute_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  data_exchange_serviceExecuteResult *self = DATA_EXCHANGE_SERVICE_EXECUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_DATA_EXCHANGE_SERVICE_EXECUTE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
data_exchange_service_execute_result_instance_init (data_exchange_serviceExecuteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_SERVER_RESPONSE__T, NULL);
  object->__isset_success = FALSE;
}

static void 
data_exchange_service_execute_result_finalize (GObject *object)
{
  data_exchange_serviceExecuteResult *tobject = DATA_EXCHANGE_SERVICE_EXECUTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
data_exchange_service_execute_result_class_init (data_exchange_serviceExecuteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = data_exchange_service_execute_result_read;
  struct_class->write = data_exchange_service_execute_result_write;

  gobject_class->finalize = data_exchange_service_execute_result_finalize;
  gobject_class->get_property = data_exchange_service_execute_result_get_property;
  gobject_class->set_property = data_exchange_service_execute_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DATA_EXCHANGE_SERVICE_EXECUTE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_SERVER_RESPONSE__T,
                         G_PARAM_READWRITE));
}

GType
data_exchange_service_execute_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (data_exchange_serviceExecuteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) data_exchange_service_execute_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (data_exchange_serviceExecuteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) data_exchange_service_execute_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "data_exchange_serviceExecuteResultType",
                                   &type_info, 0);
  }

  return type;
}

